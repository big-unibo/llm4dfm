gpt:
  - role: system
    content: |
      You are a data warehouse designer. Set the temperature to 0.1.
  - role: user
    content: |
      Carry out supply-driven conceptual
      design of a multidimensional cube using the DFM (Dimensional Fact Model), starting from the given
      source relational schema. 

      Data-driven conceptual design of a multidimensional cube starting from a source relational schema S 
      should be carried out via the following steps.
      1. Find all the functional dependencies (from here on, FDs) entailed by schema S, including 
      those that relate the primary key of a relation R to the other attributes of R, 
      those that relate a composite primary key to its component attributes, 
      and those that relate a foreign key F referencing relation R to the primary key of R.
      The result should be a directed and fully connected graph of FDs.
      2. For every pair of FDs F->K and K->A, where F is a foreign key referencing relation R, 
      K is the primary key of R, and A is an attribute of R, replace F->K and K->A with F->A.
      3. Find the roots of the obtained graph (i.e., the attributes that never appear on the right of an FD), 
      pick the root that allows reaching the greatest number of attributes by navigation FDs in the 
      correct direction, and draw the corresponding tree (i.e., exclude from the graph all FDs that cannot
      be navigated from the chosen root); the root must be renamed with the name of the corresponding relation R.

      The output I expect is a DFM schema in YAML formatted as follows: 
      (1) there is a "fact" tag including a "name" tag, listing the name of the root;
      (2) all measures (i.e., all numerical attributes directly connected to the root)
      are listed inside a "measures" tag, each is an empty item containing a "name" tag; 
      (3) all functional dependencies between attributes in a hierarchy are listed inside a "dependencies" tag: 
      each is an empty item containing a "from" tag, listing the finer attribute(s), a "to" tag, listing 
      the coarser attribute, and optionally a "role" tag; 
      (4) the "dependencies" list also includes an item from the fact to each measure; 
      (5) if a dependency is from and/or to a combination of attributes, they should be comma-separated;
      (6) all attributes and measure names must be prefixed by the name (in uppercases) of the table 
      they belong to (for instance, PERSON.Address).

      For instance, let this relational schema be given:

      CREATE TABLE TYPES (
          typeId INT PRIMARY KEY,
          typeName VARCHAR(100)
      );

      CREATE TABLE ARTICLES (
          artId INT PRIMARY KEY,
          artName VARCHAR(100),
          unitPrice FLOAT,
          type INT,
          FOREIGN KEY (type) REFERENCES TYPES(typeId)
      );

      CREATE TABLE REGIONS (
          regId INT,
          regionName VARCHAR(100),
          state VARCHAR(100),
          country VARCHAR(100),
          PRIMARY KEY (regId, state)
      );

      CREATE TABLE STORES (
          storeId INT PRIMARY KEY,
          storeName VARCHAR(100),
          storeAddress VARCHAR(100),
          regId INT,
          state VARCHAR(100),
          FOREIGN KEY (regId, state) REFERENCES REGIONS(regId, state)
      );

      CREATE TABLE PURCHASE (
          storeId INT,
          artId INT,
          date DATE,
          quantity INT,
          revenue FLOAT,
          PRIMARY KEY (storeId, artId, date),
          FOREIGN KEY (artId) REFERENCES ARTICLES(artId),
          FOREIGN KEY (storeId) REFERENCES STORES(storeId)
      );

      After step 1, the list of FDs is the following:

      - PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->PURCHASE.storeId
      - PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->PURCHASE.artId
      - PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->PURCHASE.date
      - PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->PURCHASE.quantity
      - PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->PURCHASE.revenue
      - PURCHASE.artId->ARTICLES.artId
      - PURCHASE.storeId->STORES.storeId
      - ARTICLES.artId->ARTICLES.artName
      - ARTICLES.artId->ARTICLES.unitPrice
      - ARTICLES.artId->ARTICLES.type
      - ARTICLES.type->TYPES.typeId
      - TYPES.typeId->TYPES.typeName
      - STORES.storeId->STORES.storeName
      - STORES.storeId->STORES.storeAddress
      - STORES.storeId->STORES.regId,STORES.state
      - STORES.regId,STORES.state->REGIONS.regId,REGIONS.state
      - REGIONS.regId,REGIONS.state->REGIONS.regId
      - REGIONS.regId,REGIONS.state->REGIONS.state
      - REGIONS.regId,REGIONS.state->REGIONS.regionName
      - REGIONS.state->REGIONS.country

      After step 2, the list of FDs is changed as follows:

      - PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->PURCHASE.storeId and PURCHASE.storeId->STORES.storeId 
      are replaced with PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->STORES.storeId 
      - PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->PURCHASE.artId and PURCHASE.artId->ARTICLES.artId 
      are replaced with PURCHASE.storeId,PURCHASE.artId,PURCHASE.date->ARTICLES.artId 
      - ARTICLES.artId->ARTICLES.type and ARTICLES.type->TYPES.typeId 
      are replaced with ARTICLES.artId->TYPES.typeId
      - STORES.storeId->STORES.regId,STORES.state and STORES.regId,STORES.state->REGIONS.regId,REGIONS.state
      are replaced with STORES.storeId->REGIONS.regId,REGIONS.state

      After step 3, the YAML expression of the DFM schema is obtained as follows:

      fact:
        name: PURCHASE
      measures:
        - name: PURCHASE.quantity
        - name: PURCHASE.revenue
        - name: ARTICLES.unitPrice
      dependencies:
        - from: TYPES.typeId
          to: TYPES.typeName
        - from: ARTICLES.artId
          to: ARTICLES.artName
        - from: ARTICLES.artId
          to: TYPES.typeId
          role: type
        - from: REGIONS.regId, REGIONS.state
          to: REGIONS.regionName
        - from: REGIONS.regId, REGIONS.state
          to: REGIONS.state
        - from: REGIONS.state
          to: REGIONS.country
        - from: STORES.storeId
          to: STORES.storeName
        - from: STORES.storeId
          to: STORES.storeAddress
        - from: STORES.storeId
          to: REGIONS.regId, REGIONS.state
        - from: PURCHASE
          to: PURCHASE.quantity
        - from: PURCHASE
          to: PURCHASE.revenue
        - from: PURCHASE
          to: ARTICLES.unitPrice
        - from: PURCHASE
          to: ARTICLES.artId
        - from: PURCHASE
          to: STORES.storeId
        - from: PURCHASE
          to: PURCHASE.date

      Return only the final YAML without any further information/explanation.