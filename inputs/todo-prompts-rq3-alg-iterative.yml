gpt:
  - role: system
    content: |
      You are a data warehouse designer. Set the temperature to 0.1.
  - role: user
    content: |
      Your task is to create the conceptual schema for a multidimensional cube in a supply-driven fashion, 
      i.e., starting from a source relational schema D. To this end, the first step is to create a directed 
      acyclic graph G where each node corresponds to a (simple or composite) attribute of D and each arc 
      corresponds to a functional dependency (FD).

      The output I expect is a DFM schema in YAML formatted as follows: 
      (1) the fact is a "fact" tag including a "name" tag; 
      (2) all measures are listed inside a "measures" tag, each is an empty item containing a "name" tag; 
      (3) all functional dependencies between attributes in a hierarchy are listed inside a "dependencies" tag: 
      each is an empty item containing a "from" tag, listing the finer attribute(s), and a "to" tag, 
      listing the coarser attribute(s); 
      (4) the "dependencies" list also includes an item from the fact to each dimension, and one from 
      the fact to each measure; 
      (5) if a dependency is from and/or to a combination of attributes, they should be comma-separated;
      (6) all attributes and measure names must be prefixed by the name (in uppercases) of the table 
      they belong to (for instance, PERSON.Address).

      To create the conceptual schema, you must follow a series of steps; let's start from the first one.
      
      Find a fact R. A fact is a relation that has some temporal or date attributes and includes some 
      foreign keys. The more foreign keys R has, the better candidate it is to be a fact. The primary key 
      of a fact is often a composite one. If there is a relation S that includes a foreign key referencing R, 
      then most probably S is a better candidate than R to be a fact. For instance, let this relational schema be given:

      CREATE TABLE TYPES (
          typeId INT PRIMARY KEY,
          typeName VARCHAR(100)
      );

      CREATE TABLE ARTICLES (
          artId INT PRIMARY KEY,
          artName VARCHAR(100),
          unitPrice FLOAT,
          type INT,
          FOREIGN KEY (type) REFERENCES TYPES(typeId)
      );

      CREATE TABLE REGIONS (
          regId INT,
          regionName VARCHAR(100),
          state VARCHAR(100),
          country VARCHAR(100),
          PRIMARY KEY (regId, state)
      );

      CREATE TABLE STORES (
          storeId INT PRIMARY KEY,
          storeName VARCHAR(100),
          storeAddress VARCHAR(100),
          regId INT,
          state VARCHAR(100),
          FOREIGN KEY (regId, state) REFERENCES REGIONS(regId, state)
      );

      CREATE TABLE PURCHASE (
          storeId INT,
          artId INT,
          date DATE,
          quantity INT,
          revenue FLOAT,
          PRIMARY KEY (storeId, artId, date),
          FOREIGN KEY (artId) REFERENCES ARTICLES(artId),
          FOREIGN KEY (storeId) REFERENCES STORES(storeId)
      );

      The fact here is PURCHASE: it has a DATE attribute and three foreign keys. Besides, its primary key is composite.

      Return only the YAML without any further information/explanation.
  - role: user
    content: |
      Let's go with the next step.

      INITIALIZE: Add to G the primary key of R, R.K, as a node. This node is the root of the tree to be built.

      With reference to the example shown before, G is initialized with node (storeId, artId, date), which becomes the root.

      Return only the YAML without any further information/explanation.
  - role: user
    content: |
      Let's go with the next step.
      
      EXPAND R: Add to G an arc from R.K to each other attribute of R that is not a foreign key. 
      If R.K is composite, add an arc from R.K to each of its component attributes (e.g., R.A) 
      that are not foreign keys. For each (single or composite) foreign key R.F in R that references the 
      primary key S.K of another relation S, add to G an arc from R.K to S.K then EXPAND S; if R.F has a 
      different name than S.K, use the name of R.F as a role for that arc. If R.F is composite, 
      node S.K should be named with a comma-separated list of its components, then should be expanded 
      in its components. Repeat until no more arcs can be added. Note that, if you have a composite key K 
      for a relation R, you should never have an arc from a component attribute of K towards K. 

      With reference to the example shown before, we must do the following.
      
      - EXPAND PURCHASE: Five arcs are added to G, going from the primary key of PURCHASE, (storeId, artId, date), to nodes STORES.storeId, ARTICLES.artId, PURCHASE.date, PURCHASE.quantity, and PURCHASE.revenue, respectively. There are two foreign keys in PURCHASE, namely storeId and artId, so EXPAND is called twice on STORES (see 2.1) and ARTICLES (see 2.2).

      -- EXPAND STORES: Three arcs are added to G, going from the primary key of STORES, STORES.storeId, to nodes STORES.storeName, STORES.storeAddress, and "REGIONS.regId,REGIONS.state", respectively. The latter node is treated as a whole because it is a composite foreign key. There is one foreign key in STORES, so EXPAND is called once on REGIONS (see 2.1.1).

      --- EXPAND REGIONS: Three arcs are added to G, from REGIONS.regId to REGIONS.regionName, REGIONS.state, and REGIONS.country, respectively. There are no foreign keys in REGIONS, so no more calls to EXPAND are done here.

      -- EXPAND ARTICLES: Three arcs are added to G, from ARTICLES.artId to ARTICLES.artName, ARTICLES.unitPrice, and TYPES.typeId (the latter with role "type"). There is one foreign key in ARTICLES, namely type, so EXPAND is called once on TYPES (see 2.2.1).

      --- EXPAND TYPES: One arc is added to G, from TYPES.typeId to TYPES.typeName. There are no foreign keys in TYPES, so no more calls to EXPAND are done here.

      Return only the YAML without any further information/explanation.
  - role: user
    content: |
      Let's go with the next step.
      
      REARRANGE G: In some cases, some additional FDs may be inferred having some knowledge of the 
      application domain. For instance, for geographical data, it often is city->region, region->state, 
      state->country, country->area (while normally it is not address->city). As another examples, 
      the model of a car normally functionally determines its brand. In this case, you should 
      add these FDs to G and remove those transitively implied.
      
      With reference to the example shown before, since we believe that REGIONS.state-> REGIONS.country,
      add this arc and remove the transitive one from REGIONS.regId to REGIONS.country.
      
      Return only the YAML without any further information/explanation.
  - role: user
    content: |
      Let's go with the next step.
      
      RENAME THE FACT: Take the root of the tree, K, and rename it to the name of the relation chosen as a fact.
      
      With reference to the example shown before, rename the root (storeId, artId, date) to PURCHASE.
      
      Return only the YAML without any further information/explanation.
  - role: user
    content: |
      Let's go with the next step.
      
      CHOOSE MEASURES: Label as measures the numerical attributes.
      
      With reference to the example shown before, quantity and revenue are numerical, so label them as measures.

      The YAML expression of the DFM schema obtained in the end is the following:

      fact:
        name: PURCHASE
      measures:
        - name: PURCHASE.quantity
        - name: PURCHASE.revenue
        - name: ARTICLES.unitPrice
      dependencies:
        - from: TYPES.typeId
          to: TYPES.typeName
        - from: ARTICLES.artId
          to: ARTICLES.artName
        - from: ARTICLES.artId
          to: TYPES.typeId
          role: type
        - from: REGIONS.regId, REGIONS.state
          to: REGIONS.regionName
        - from: REGIONS.regId, REGIONS.state
          to: REGIONS.state
        - from: REGIONS.state
          to: REGIONS.country
        - from: STORES.storeId
          to: STORES.storeName
        - from: STORES.storeId
          to: STORES.storeAddress
        - from: STORES.storeId
          to: REGIONS.regId, REGIONS.state
        - from: PURCHASE
          to: PURCHASE.quantity
        - from: PURCHASE
          to: PURCHASE.revenue
        - from: PURCHASE
          to: ARTICLES.unitPrice
        - from: PURCHASE
          to: ARTICLES.artId
        - from: PURCHASE
          to: STORES.storeId
        - from: PURCHASE
          to: PURCHASE.date

      Return only the YAML without any further information/explanation.
