gpt:
  - role: system
    content: |
      You are a data warehouse designer. Set the temperature to 0.1.
  - role: user
    content: |
      Carry out supply-driven conceptual
      design of a multidimensional cube using the DFM (Dimensional Fact Model), starting from the following
      source relational schema. 
      The output I expect is a DFM schema in YAML formatted as follows: 
      (1) the fact is a "fact" tag including a "name" tag; 
      (2) all measures are listed inside a "measures" tag, each is an empty item containing a "name" tag; 
      (3) all functional dependencies between attributes in a hierarchy are listed inside a "dependencies" tag: 
      each is an empty item containing a "from" tag, listing the finer attribute(s), and a "to" tag, 
      listing the coarser attribute(s); 
      (4) the "dependencies" list also includes an item from the fact to each dimension, and one from 
      the fact to each measure; 
      (5) if a dependency is from and/or to a combination of attributes, they should be comma-separated;
      (6) all attributes and measure names must be prefixed by the name (in uppercases) of the table 
      they belong to (for instance, PERSON.Address).

      For instance, let this relational schema be given:

      CREATE TABLE TYPES (
          typeId INT PRIMARY KEY,
          typeName VARCHAR(100)
      );

      CREATE TABLE ARTICLES (
          artId INT PRIMARY KEY,
          artName VARCHAR(100),
          unitPrice FLOAT,
          type INT,
          FOREIGN KEY (type) REFERENCES TYPES(typeId)
      );

      CREATE TABLE REGIONS (
          regId INT,
          regionName VARCHAR(100),
          state VARCHAR(100),
          country VARCHAR(100),
          PRIMARY KEY (regId, state)
      );

      CREATE TABLE STORES (
          storeId INT PRIMARY KEY,
          storeName VARCHAR(100),
          storeAddress VARCHAR(100),
          regId INT,
          state VARCHAR(100),
          FOREIGN KEY (regId, state) REFERENCES REGIONS(regId, state)
      );

      CREATE TABLE PURCHASE (
          storeId INT,
          artId INT,
          date DATE,
          quantity INT,
          revenue FLOAT,
          PRIMARY KEY (storeId, artId, date),
          FOREIGN KEY (artId) REFERENCES ARTICLES(artId),
          FOREIGN KEY (storeId) REFERENCES STORES(storeId)
      );
      
      The YAML expression of the DFM schema obtained in the end is the following:

      fact:
        name: PURCHASE
      measures:
        - name: PURCHASE.quantity
        - name: PURCHASE.revenue
        - name: ARTICLES.unitPrice
      dependencies:
        - from: TYPES.typeId
          to: TYPES.typeName
        - from: ARTICLES.artId
          to: ARTICLES.artName
        - from: ARTICLES.artId
          to: TYPES.typeId
          role: type
        - from: REGIONS.regId, REGIONS.state
          to: REGIONS.regionName
        - from: REGIONS.regId, REGIONS.state
          to: REGIONS.state
        - from: REGIONS.state
          to: REGIONS.country
        - from: STORES.storeId
          to: STORES.storeName
        - from: STORES.storeId
          to: STORES.storeAddress
        - from: STORES.storeId
          to: REGIONS.regId, REGIONS.state
        - from: PURCHASE
          to: PURCHASE.quantity
        - from: PURCHASE
          to: PURCHASE.revenue
        - from: PURCHASE
          to: ARTICLES.unitPrice
        - from: PURCHASE
          to: ARTICLES.artId
        - from: PURCHASE
          to: STORES.storeId
        - from: PURCHASE
          to: PURCHASE.date

      Consider now this second example; the following logical schema describes an operational database for credit card payments.
    
      CREATE TABLE HOLDERS (
      HolderCode INT PRIMARY KEY,
      FirstName VARCHAR(100),
      LastName VARCHAR(100),
      BirthDate DATE,
      Job VARCHAR(100),
      IncomeRange VARCHAR(100),
      Quality VARCHAR(100)
      );
      
      CREATE TABLE CARD_TYPES (
      TypeCode INT PRIMARY KEY,
      Circuit VARCHAR(100),
      IssuingBank VARCHAR(100),
      Address VARCHAR(100),
      Country VARCHAR(100),
      CardName VARCHAR(100),
      Color VARCHAR(100)
      );
      
      CREATE TABLE STORES (
      StoreCode INT PRIMARY KEY,
      Name VARCHAR(100),
      Address VARCHAR(100),
      Country VARCHAR(100),
      Area VARCHAR(100),
      WebSite VARCHAR(100),
      Email VARCHAR(100),
      Type VARCHAR(100)
      );
      
      CREATE TABLE CREDIT_CARDS (
      CCNumber INT PRIMARY KEY,
      TypeCode INT,
      HolderCode INT,
      ExpirationDate DATE,
      CreditLimit FLOAT,
      FOREIGN KEY (TypeCode) REFERENCES CARD_TYPES(TypeCode),
      FOREIGN KEY (HolderCode) REFERENCES HOLDERS(HolderCode)
      );
      
      CREATE TABLE PURCHASES (
      PurchCode INT PRIMARY KEY,
      Date DATE,
      Amount FLOAT,
      Currency VARCHAR(10),
      Exchange FLOAT,
      CCNumber INT,
      StoreCode INT,
      FOREIGN KEY (CCNumber) REFERENCES CREDIT_CARDS(CCNumber),
      FOREIGN KEY (StoreCode) REFERENCES STORES(StoreCode)
      );

      In this second example, the YAML expression of the DFM schema obtained in the end is the following.

      fact:
        name: PURCHASES
      measures:
        - name: PURCHASES.Amount
        - name: PURCHASES.Exchange
        - name: CREDIT_CARDS.CreditLimit
      dependencies:
        - from: PURCHASES
          to: PURCHASES.Amount
        - from: PURCHASES
          to: PURCHASES.Exchange
        - from: PURCHASES
          to: CREDIT_CARDS.CCNumber
        - from: PURCHASES
          to: STORES.StoreCode
        - from: PURCHASES
          to: PURCHASES.Currency
        - from: PURCHASES
          to: PURCHASES.Date
        - from: CREDIT_CARDS.CCNumber
          to: CARD_TYPES.TypeCode
        - from: CREDIT_CARDS.CCNumber
          to: HOLDERS.HolderCode
        - from: CREDIT_CARDS.CCNumber
          to: CREDIT_CARDS.ExpirationDate
        - from: PURCHASES
          to: CREDIT_CARDS.CreditLimit
        - from: CARD_TYPES.TypeCode
          to: CARD_TYPES.Circuit
        - from: CARD_TYPES.TypeCode
          to: CARD_TYPES.IssuingBank
        - from: CARD_TYPES.IssuingBank
          to: CARD_TYPES.Address
        - from: CARD_TYPES.IssuingBank
          to: CARD_TYPES.Country
        - from: CARD_TYPES.TypeCode
          to: CARD_TYPES.CardName
        - from: CARD_TYPES.TypeCode
          to: CARD_TYPES.Color
        - from: HOLDERS.HolderCode
          to: HOLDERS.FirstName
        - from: HOLDERS.HolderCode
          to: HOLDERS.LastName
        - from: HOLDERS.HolderCode
          to: HOLDERS.BirthDate
        - from: HOLDERS.HolderCode
          to: HOLDERS.Job
        - from: HOLDERS.HolderCode
          to: HOLDERS.IncomeRange
        - from: HOLDERS.HolderCode
          to: HOLDERS.Quality
        - from: STORES.StoreCode
          to: STORES.Name
        - from: STORES.StoreCode
          to: STORES.Address
        - from: STORES.StoreCode
          to: STORES.Country
        - from: STORES.Country
          to: STORES.Area
        - from: STORES.StoreCode
          to: STORES.WebSite
        - from: STORES.StoreCode
          to: STORES.Email
        - from: STORES.StoreCode
          to: STORES.Type

      Return only the YAML without any further information/explanation.