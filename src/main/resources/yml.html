<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Comparison</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/0.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.5/jspdf.min.js"></script>

    <style>
        #network {
            width: 80%;
            height: 600px;
            border: 1px solid black;
            display: inline-block;
            vertical-align: top;
            resize: both;
            overflow: auto;
        }
        .textarea-container {
            width: 40%;
            display: inline-block;
            vertical-align: top;
            margin-right: 20px;
        }
        textarea {
            width: 100%;
            height: 200px;
        }
        #results {
            width: 18%;
            display: inline-block;
            vertical-align: top;
            margin-left: 10px;
        }
        #results table {
            width: 100%;
            border-collapse: collapse;
        }
        #results th, #results td {
            border: 1px solid black;
            padding: 5px;
            text-align: left;
        }
        #results th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <div>
        <form id="yamlConfigForm">
            <div>
                <label for="file_yaml_llm">File LLM:</label>
                <input type="file" id="file_yaml_llm" name="file_yaml_llm" placeholder="Select LLM file yaml">
            </div>
            <div>
                <label for="file_yaml_gt">File ground-truth:</label>
                <input type="file" id="file_yaml_gt" name="file_yaml_gt" placeholder="Select GT file yaml">
                <label for="demand_driven">Demand driven?</label>
                <input type="checkbox" id="demand_driven" name="demand_driven">
            </div>
        </form>
    </div>
    <div class="textarea-container">
        <h2>YAML LLM</h2>
        <textarea id="yaml_llm" rows="10" cols="30">
dependencies:
- from: node1
  to: node2
- from: node1
  to: node3
- from: node1
  to: node4
- from: node4
  to: node5
fact:
  name: node1
measures:
- name: node2
- name: node3          
        </textarea>
    </div>
    <div class="textarea-container">
        <h2>YAML Ground Truth</h2>
        <textarea id="yaml_gt" rows="10" cols="30">
dependencies:
  - from: node2
    to: node3
  - from: node3
    to: node4
fact:
  name: node2
measures:
  - name: node3
        </textarea>
    </div>
    <div>
        <button onclick="drawGraph('first')">Draw LLM</button>
        <button onclick="drawGraph('second')">Draw Ground Truth</button>
        <button onclick="compareGraphs()">Compare</button>
        <p>
            If drawing:
            - WHITE: the fact
            - ORANGE: the measures
            - BLUE: dimensions
            - GREY: everything else
        </p>
        <p>
            If comparing:
            - GREEN: true positive (found in both LLM and Ground Truth)
            - RED: false positive (found by LMM, but not in Ground Truth)
            - GREY: false negative (not found by LLM, but in Ground Truth)
        </p>
    </div>
    <h2>Graph</h2>
    <!-- <button onclick="exportGraphToPDF()">Export Graph to PDF</button> -->
    <div id="network"></div>
    <div id="results"></div>

    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            // Select the file input element
            const fileInputLLM = document.getElementById('file_yaml_llm');
            const fileInputGT = document.getElementById('file_yaml_gt');
            const isDemandDrivenElem = document.getElementById('demand_driven');

            // Add event listener to handle file selection
            fileInputLLM.addEventListener('change', function(event) {
                // Get the selected file
                const file = event.target.files[0];
                if (file) {
                    // Create a FileReader object
                    const reader = new FileReader();

                    // Define what to do when the file is read successfully
                    reader.onload = function(e) {
                        const fileContent = e.target.result;
                        const yamlData = parseYAML(fileContent);


                        if (yamlData) {
                            let text_loaded_out = ""
                            if (yamlData.hasOwnProperty('output_preprocessed')) {
                                text_loaded_out = jsyaml.dump(yamlData.output_preprocessed[yamlData.output_preprocessed.length-1]);
                            } else {
                                text_loaded_out = jsyaml.dump(yamlData.output[yamlData.output.length-1]);
                            }
                            document.getElementById('yaml_llm').value = text_loaded_out;
                            if (yamlData.hasOwnProperty('gt_preprocessed')) {
                                document.getElementById('yaml_gt').value = jsyaml.dump(yamlData.gt_preprocessed);
                            }
                        }
                    };
                    reader.readAsText(file)
                } else {
                    console.log('No file selected');
                }
            });

            fileInputGT.addEventListener('change', function(event) {
                const isDemandDrive = isDemandDrivenElem.checked;

                const file = event.target.files[0];

                if (file) {
                    // Create a FileReader object
                    const reader = new FileReader();

                    // Define what to do when the file is read successfully
                    reader.onload = function(e) {
                        const fileContent = e.target.result;
                        const yamlData = parseYAML(fileContent);

                        if (yamlData) {
                            let text_loaded = ""
                            if (isDemandDrive) {
                                text_loaded = jsyaml.dump(yamlData.demand_driven);
                            } else {
                                text_loaded = jsyaml.dump(yamlData.supply_driven);
                            }
                            document.getElementById('yaml_gt').value = text_loaded;
                        }
                    };
                    reader.readAsText(file)
                } else {
                }
            });

            isDemandDrivenElem.addEventListener('change', function() {
                // Trigger the file input's change event manually
                const event = new Event('change');
                fileInputGT.dispatchEvent(event);
            });
        });

        function parseYAML(input) {
            try {
                return removeWhitespacesFromValues(jsyaml.load(input));
            } catch (e) {
                console.error(e);
                return null;
            }
        }

        function removeWhitespacesFromValues(obj) {
            // Recursively traverse the object
            for (let key in obj) {
                if (typeof obj[key] === 'object' && obj[key] !== null) {
                    // If the value is an object or array, recurse
                    removeWhitespacesFromValues(obj[key]);
                } else if (typeof obj[key] === 'string') {
                    // If the value is a string, remove all whitespaces
                    obj[key] = obj[key].replace(/\s+/g, '').replaceAll('_','');
                }
            }
            return obj;
        }


        function extractGraphData(yaml) {
            const nodes = new Map();
            const edges = new Set();
            let factNode = null;
            const measures = new Set();

            if (yaml) {
                // Handle dependencies
                if (yaml.dependencies) {
                    yaml.dependencies.forEach(dep => {
                        if (!dep.refinements || dep.refinements !== 'created') {
                            dep.from = "n_" + dep.from;
                            dep.to = "n_" + dep.to;
                            edges.add({ from: dep.from, to: dep.to, role: dep.role });
                            nodes.set(dep.from, { id: dep.from });
                            nodes.set(dep.to, { id: dep.to });
                        }
                    });
                }

                // Handle fact
                if (yaml.fact && yaml.fact.name) {
                    factNode = "n_" + yaml.fact.name;
                    nodes.set(factNode, { id: factNode, tag: 'fact' });
                }

                // Handle measures
                if (yaml.measures) {
                    yaml.measures.forEach(measure => {
                        if (measure.name) {
                            measure.name = "n_" + measure.name;
                            measures.add(measure.name);
                            nodes.set(measure.name, {id: measure.name, tag: 'measure'});
                        }
                    });
                }

                // Derive dimensions
                if (factNode) {
                    edges.forEach(edge => {
                        if (edge.from === factNode && !measures.has(edge.to)) {
                            nodes.set(edge.to, { id: edge.to, tag: 'dimension' });
                        }
                    });
                }
            }
            return { nodes: Array.from(nodes.values()), edges: Array.from(edges) };
        }

        function getNodeTitle(title){
            if(title.startsWith("n_"))
                return title.slice(2);
            else 
                return title;
        }

        function getColorByTag(tag) {
            switch(tag) {
                case 'fact': return 'white';
                case 'measure': return 'orange';
                case 'dimension': return 'lightblue';
                default: return 'lightgrey';
            }
        }

        function drawGraph(which) {
            const yaml = which === 'first' ? document.getElementById('yaml_llm').value : document.getElementById('yaml_gt').value;
            const graph = extractGraphData(parseYAML(yaml));

            // Clear existing network
            const container = document.getElementById('network');
            container.innerHTML = '';

            const nodes = [];
            const edges = [];
            let factNodeId = null;

            // First, identify the fact node
            graph.nodes.forEach(node => {
                node.id = node.id.replace(/\s/g,'')
                if (node.tag === 'fact') {
                    factNodeId = node.id;
                }
            });

            graph.nodes.forEach(node => {
                if (node.tag === 'fact') {
                    // Get the measure nodes as strings and list them inside the fact node
                    const measureList = Array.from(graph.nodes.filter(n => n.tag === 'measure').map(n => polishNodeName(n.id))).join('\n');

                    // Display the fact node as a square, uppercase, and underlined
                    nodes.push({
                        id: node.id,
                        label: `${getNodeTitle(node.id).toUpperCase()}\n\n${measureList}`,  // Combine fact and measures
                        shape: 'box',  // Shape as square
                        font: {
                            color: 'black',
                            size: 14,
                            face: 'arial'
                        },
                        color: { border: 'black', background: 'white' }, // White square
                        shapeProperties: { borderRadius: 0 }, // Sharp corners
                        title: getNodeTitle(node.id)
                    });
                } else if (node.tag === 'dimension' && node.id !== factNodeId) {
                    // For dimension nodes (directly connected to fact) set them to light blue
                    nodes.push({
                        id: node.id,
                        label: polishNodeName(node.id),
                        color: { border: 'black', background: 'lightblue' }, // Lightblue for dimensions
                        title: getNodeTitle(node.id)
                    });
                } else if (node.tag !== 'measure') {
                    // For all other nodes (non-measures), set background to white
                    nodes.push({
                        id: node.id,
                        label: polishNodeName(node.id),
                        color: { border: 'black', background: 'white' },  // Set background to white for other nodes
                        title: getNodeTitle(node.id)
                    });
                }
            });

            // Add edges for non-measure related nodes (since measure edges are ignored)
            graph.edges.forEach(edge => {
                if (edge.role !== 'measure') {
                    edges.push({ from: edge.from, to: edge.to, color: 'black', title: edge.role });
                }
            });

            const data = {
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges)
            };
            const options = {
                edges: {
                    color: { color: 'black' },
                    arrows: { to: { enabled: true, scaleFactor: 0.5 } }
                },
                layout: {
                    hierarchical: false
                }
            };
            new vis.Network(container, data, options);
        }


        function compareGraphs() {
            const yaml2 = document.getElementById('yaml_llm').value;
            const yaml1 = document.getElementById('yaml_gt').value;

            const graph1 = extractGraphData(parseYAML(yaml1));
            const graph2 = extractGraphData(parseYAML(yaml2));

            // Clear existing network
            const container = document.getElementById('network');
            container.innerHTML = '';

            const nodes = [];
            const edges = [];

            graph1.nodes.forEach(node => {
                node.id = node.id.replace(/\s/g,'')
            })
            graph2.nodes.forEach(node => {
                node.id = node.id.replace(/\s/g,'')
            })

            const allNodes = new Map();
            graph2.nodes.forEach(node => allNodes.set(node.id.toLowerCase(), { ...node, casedname: node.id, color: 'red' }));
            graph1.nodes.forEach(node => {
                if (allNodes.has(node.id.toLowerCase())) {
                    allNodes.get(node.id.toLowerCase()).color = 'lightgreen';
                } else {
                    allNodes.set(node.id.toLowerCase(), { ...node, casedname: node.id, color: 'lightgrey' });
                }
            });

            const allEdges = new Map();
            graph2.edges.forEach(edge => allEdges.set(JSON.stringify({ from: edge.from.toLowerCase(), to: edge.to.toLowerCase(), title: edge.role }), 'red'));
            graph1.edges.forEach(edge => {
                const edgeStr = JSON.stringify({ from: edge.from.toLowerCase(), to: edge.to.toLowerCase(), title: edge.role });
                if (allEdges.has(edgeStr)) {
                    allEdges.set(edgeStr, 'lightgreen');
                } else {
                    allEdges.set(edgeStr, 'lightgrey');
                }
            });

            let truePositiveNodes = 0;
            let falsePositiveNodes = 0;
            let falseNegativeNodes = 0;
            let truePositiveEdges = 0;
            let falsePositiveEdges = 0;
            let falseNegativeEdges = 0;

            allNodes.forEach((node, id) => {
                nodes.push({ id: node.id.toLowerCase(), label: polishNodeName(node.casedname), color: { border: 'black', background: node.color }, title: getNodeTitle(node.id) });
                if (node.color === 'lightgreen') truePositiveNodes++;
                if (node.color === 'red') falsePositiveNodes++;
                if (node.color === 'lightgrey') falseNegativeNodes++;
            });

            allEdges.forEach((color, edgeStr) => {
                const edge = JSON.parse(edgeStr);
                edges.push({ from: edge.from, to: edge.to, color: { color: color } });
                if (color === 'lightgreen') truePositiveEdges++;
                if (color === 'red') falsePositiveEdges++;
                if (color === 'lightgrey') falseNegativeEdges++;
            });

            const data = {
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges)
            };
            const options = {
                edges: {
                    arrows: { to: { enabled: true, scaleFactor: 0.5 } }
                },
                layout: {
                    hierarchical: false
                }
            };
            new vis.Network(container, data, options);

            // Calculate metrics
            const precisionNodes = truePositiveNodes / (truePositiveNodes + falsePositiveNodes);
            const recallNodes = truePositiveNodes / (truePositiveNodes + falseNegativeNodes);
            let f1Nodes

            if (precisionNodes !== 0 || recallNodes !== 0) {
                f1Nodes = 2 * (precisionNodes * recallNodes) / (precisionNodes + recallNodes);
            } else {
                f1Nodes = 0
            }

            const precisionEdges = truePositiveEdges / (truePositiveEdges + falsePositiveEdges);
            const recallEdges = truePositiveEdges / (truePositiveEdges + falseNegativeEdges);
            let f1Edges

            if (precisionEdges !== 0 || recallEdges !== 0) {
                f1Edges = 2 * (precisionEdges * recallEdges) / (precisionEdges + recallEdges);
            } else {
                f1Edges = 0
            }

            // Display metrics
            document.getElementById('results').innerHTML = `
                <h3>Comparison Results</h3>
                <table>
                    <tr>
                        <th>Metric</th>
                        <th>Nodes</th>
                        <th>Edges</th>
                    </tr>
                    <tr>
                        <td>True Positives</td>
                        <td>${truePositiveNodes}</td>
                        <td>${truePositiveEdges}</td>
                    </tr>
                    <tr>
                        <td>False Positives</td>
                        <td>${falsePositiveNodes}</td>
                        <td>${falsePositiveEdges}</td>
                    </tr>
                    <tr>
                        <td>False Negatives</td>
                        <td>${falseNegativeNodes}</td>
                        <td>${falseNegativeEdges}</td>
                    </tr>
                    <tr>
                        <td>Precision</td>
                        <td>${precisionNodes.toFixed(2)}</td>
                        <td>${precisionEdges.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Recall</td>
                        <td>${recallNodes.toFixed(2)}</td>
                        <td>${recallEdges.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>F1-Measure</td>
                        <td>${f1Nodes.toFixed(2)}</td>
                        <td>${f1Edges.toFixed(2)}</td>
                    </tr>
                </table>

            `;
        }

        function polishNodeName(name) {
            if(name.startsWith("n_")){
                name = name.slice(2);
            }
            return name.split(',').map(part => {
                const [prefix, suffix] = part.trim().split('.');
                if (suffix) {
                    const polishedPrefix = prefix.length > 4 ? prefix.slice(0, 4) : prefix;
                    //const polishedSuffix = suffix.length > 10 ? suffix.slice(0, 10) : suffix;
                    return `${polishedPrefix.toUpperCase()}.${suffix}`;
                } else {
                    // const polishedPrefix = prefix.length > 10 ? prefix.slice(0, 10) : prefix;
                    return prefix;
                }
            }).join('\n');
        }

        function exportGraphToPDF() {
            html2canvas(document.getElementById('network'), {
                useCORS: true,  // Enable cross-origin images if needed
            }).then(function(canvas) {
                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF('landscape');
                
                // Add the image to the PDF
                const imgWidth = 280;
                const pageHeight = pdf.internal.pageSize.height;
                const imgHeight = canvas.height * imgWidth / canvas.width;
                const position = 10;

                pdf.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
                pdf.save('graph.pdf');
            });
        }

    </script>
</body>
</html>
